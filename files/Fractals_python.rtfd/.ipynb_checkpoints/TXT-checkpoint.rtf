{\rtf1\ansi\ansicpg1252\cocoartf2707
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red151\green0\blue126;\red247\green247\blue247;\red31\green31\blue31;
\red73\green17\blue135;\red13\green100\blue1;\red20\green0\blue196;\red181\green0\blue19;}
{\*\expandedcolortbl;;\cssrgb\c66667\c5098\c56863;\cssrgb\c97647\c97647\c97647;\cssrgb\c16078\c16078\c16078;
\cssrgb\c36078\c14902\c60000;\cssrgb\c0\c45490\c0;\cssrgb\c10980\c0\c81176;\cssrgb\c76863\c10196\c8627;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
import\cf4  numpy \cf2 as\cf4  np\cb1 \
\cf2 \cb3 from\cf4  PIL \cf2 import\cf4  Image\cb1 \
\cf2 \cb3 import\cf4  math\cb1 \
\
\cf2 \cb3 def\cf4  plot_line(\cf5 from_coordinates, to_coordinates, thickness, colour, pixels\cf4 ):\cb1 \
\
\cb3     \cf6 # Figure out the boundaries of our pixel array\cf4 \cb1 \
\cb3     max_x_coordinate = \cf5 len\cf4 (pixels[\cf7 0\cf4 ])\cb1 \
\cb3     max_y_coordinate = \cf5 len\cf4 (pixels)\cb1 \
\
\cb3     \cf6 # The distances along the x and y axis between the 2 points\cf4 \cb1 \
\cb3     horizontal_distance = to_coordinates[\cf7 1\cf4 ] - from_coordinates[\cf7 1\cf4 ]\cb1 \
\cb3     vertical_distance = to_coordinates[\cf7 0\cf4 ] - from_coordinates[\cf7 0\cf4 ]\cb1 \
\
\cb3     \cf6 # The total distance between the two points\cf4 \cb1 \
\cb3     distance =  math.sqrt((to_coordinates[\cf7 1\cf4 ] - from_coordinates[\cf7 1\cf4 ])**\cf7 2\cf4  \\\cb1 \
\cb3                 + (to_coordinates[\cf7 0\cf4 ] - from_coordinates[\cf7 0\cf4 ])**\cf7 2\cf4 )\cb1 \
\
\cb3     \cf6 # How far we will step forwards each time we colour in a new pixel\cf4 \cb1 \
\cb3     horizontal_step = horizontal_distance/distance\cb1 \
\cb3     vertical_step = vertical_distance/distance\cb1 \
\
\cb3     \cf6 # At this point, we enter the loop to draw the line in our pixel array\cf4 \cb1 \
\cb3     \cf6 # Each iteration of the loop will add a new point along our line\cf4 \cb1 \
\cb3     \cf2 for\cf4  i \cf2 in\cf4  \cf5 range\cf4 (\cf5 round\cf4 (distance)):\cb1 \
\cb3         \cb1 \
\cb3         \cf6 # These 2 coordinates are the ones at the center of our line\cf4 \cb1 \
\cb3         current_x_coordinate = \cf5 round\cf4 (from_coordinates[\cf7 1\cf4 ] + (horizontal_step*i))\cb1 \
\cb3         current_y_coordinate = \cf5 round\cf4 (from_coordinates[\cf7 0\cf4 ] + (vertical_step*i))\cb1 \
\
\cb3         \cf6 # Once we have the coordinates of our point, \cf4 \cb1 \
\cb3         \cf6 # we draw around the coordinates of size 'thickness'\cf4 \cb1 \
\cb3         \cf2 for\cf4  x \cf2 in\cf4  \cf5 range\cf4  (-thickness, thickness):\cb1 \
\cb3             \cf2 for\cf4  y \cf2 in\cf4  \cf5 range\cf4  (-thickness, thickness):\cb1 \
\cb3                 x_value = current_x_coordinate + x\cb1 \
\cb3                 y_value = current_y_coordinate + y\cb1 \
\
\cb3                 \cf2 if\cf4  (x_value > \cf7 0\cf4  \cf2 and\cf4  x_value < max_x_coordinate \cf2 and\cf4  \\\cb1 \
\cb3                     y_value > \cf7 0\cf4  \cf2 and\cf4  y_value < max_y_coordinate):\cb1 \
\cb3                     pixels[y_value][x_value] = colour\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 # Define the size of our image\cf4 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 pixels = np.zeros( (\cf7 500\cf4 ,\cf7 500\cf4 ,\cf7 3\cf4 ), dtype=np.uint8 )\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 # Draw a line\cf4 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 plot_line([\cf7 0\cf4 ,\cf7 0\cf4 ], [\cf7 499\cf4 ,\cf7 499\cf4 ], \cf7 1\cf4 , [\cf7 255\cf4 ,\cf7 200\cf4 ,\cf7 0\cf4 ], pixels)\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 # Turn our pixel array into a real picture\cf4 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 img = Image.fromarray(pixels)\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 # Show our picture, and save it\cf4 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 img.show()\cb1 \
\cb3 img.save(\cf8 'Line.png'\cf4 )\
\
\'97\'97\'97\'97\'97\'97\cf4 \cb3 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\cf2 \cb3 def\cf4  draw_triangle(\cf5 center, side_length, thickness, colour, pixels\cf4 ):\cb1 \
\cb3     \cb1 \
\cb3     \cf6 # The height of an equilateral triangle is, h = \'bd(\uc0\u8730 3a)\cf4 \cb1 \
\cb3     \cf6 # where 'a' is the side length\cf4 \cb1 \
\cb3     triangle_height = \cf5 round\cf4 (side_length * math.sqrt(\cf7 3\cf4 )/\cf7 2\cf4 )\cb1 \
\
\cb3     \cf6 # The top corner\cf4 \cb1 \
\cb3     top = [center[\cf7 0\cf4 ] - triangle_height/\cf7 2\cf4 , center[\cf7 1\cf4 ]]\cb1 \
\
\cb3     \cf6 # Bottom left corner\cf4 \cb1 \
\cb3     bottom_left = [center[\cf7 0\cf4 ] + triangle_height/\cf7 2\cf4 , center[\cf7 1\cf4 ] - side_length/\cf7 2\cf4 ]\cb1 \
\
\cb3     \cf6 # Bottom right corner\cf4 \cb1 \
\cb3     bottom_right = [center[\cf7 0\cf4 ] + triangle_height/\cf7 2\cf4 , center[\cf7 1\cf4 ] + side_length/\cf7 2\cf4 ]\cb1 \
\
\cb3     \cf6 # Draw a line between each corner to complete the triangle\cf4 \cb1 \
\cb3     plot_line(top, bottom_left, thickness, colour, pixels)\cb1 \
\cb3     plot_line(top, bottom_right, thickness, colour, pixels)\cb1 \
\cb3     plot_line(bottom_left, bottom_right, thickness, colour, pixels)\
\
\'97\'97\'97\'97\cf4 \cb3 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
\cf2 \cb3 def\cf4  rotate(\cf5 coordinate, center_point, degrees\cf4 ):\cb1 \
\cb3     \cf6 # Subtract the point we are rotating around from our coordinate\cf4 \cb1 \
\cb3     x = (coordinate[\cf7 0\cf4 ] - center_point[\cf7 0\cf4 ])\cb1 \
\cb3     y = (coordinate[\cf7 1\cf4 ] - center_point[\cf7 1\cf4 ])\cb1 \
\
\cb3     \cf6 # Python's cos and sin functions take radians instead of degrees\cf4 \cb1 \
\cb3     radians = math.radians(degrees)\cb1 \
\
\cb3     \cf6 # Calculate our rotated points \cf4 \cb1 \
\cb3     new_x = (x * math.cos(radians)) - (y * math.sin(radians))\cb1 \
\cb3     new_y = (y * math.cos(radians)) + (x * math.sin(radians))\cb1 \
\
\cb3     \cf6 # Add back our offset we subtracted at the beginning to our rotated points\cf4 \cb1 \
\cb3     \cf2 return\cf4  [new_x + center_point[\cf7 0\cf4 ], new_y + center_point[\cf7 1\cf4 ]]\
\
\'97\'97\'97\'97\'97\'97\cf4 \cb3 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
\cf2 \cb3 def\cf4  draw_triangle(\cf5 center, side_length, degrees_rotate, thickness, colour, \\\cf5 \cb1 \
\cf5 \cb3                   pixels, shrink_side_by, iteration, max_depth\cf4 ):\cb1 \
\cb3     \cb1 \
\cb3     \cf6 # The height of an equilateral triangle is, h = \'bd(\uc0\u8730 3a) \cf4 \cb1 \
\cb3     \cf6 # where 'a' is the side length\cf4 \cb1 \
\cb3     triangle_height = side_length * math.sqrt(\cf7 3\cf4 )/\cf7 2\cf4 \cb1 \
\
\cb3     \cf6 # The top corner\cf4 \cb1 \
\cb3     top = [center[\cf7 0\cf4 ] - triangle_height/\cf7 2\cf4 , center[\cf7 1\cf4 ]]\cb1 \
\
\cb3     \cf6 # Bottom left corner\cf4 \cb1 \
\cb3     bottom_left = [center[\cf7 0\cf4 ] + triangle_height/\cf7 2\cf4 , center[\cf7 1\cf4 ] - side_length/\cf7 2\cf4 ]\cb1 \
\
\cb3     \cf6 # Bottom right corner\cf4 \cb1 \
\cb3     bottom_right = [center[\cf7 0\cf4 ] + triangle_height/\cf7 2\cf4 , center[\cf7 1\cf4 ] + side_length/\cf7 2\cf4 ]\cb1 \
\
\cb3     \cf2 if\cf4  (degrees_rotate != \cf7 0\cf4 ):\cb1 \
\cb3         top = rotate(top, center, degrees_rotate)\cb1 \
\cb3         bottom_left = rotate(bottom_left, center, degrees_rotate)\cb1 \
\cb3         bottom_right = rotate(bottom_right, center, degrees_rotate)\cb1 \
\
\cb3     \cf6 # Coordinates between each edge of the triangle\cf4 \cb1 \
\cb3     lines = [[top, bottom_left],[top, bottom_right],[bottom_left, bottom_right]]\cb1 \
\
\cb3     line_number = \cf7 0\cf4 \cb1 \
\
\cb3     \cf6 # Draw a line between each corner to complete the triangle\cf4 \cb1 \
\cb3     \cf2 for\cf4  line \cf2 in\cf4  lines:\cb1 \
\cb3         line_number += \cf7 1\cf4 \cb1 \
\
\cb3         plot_line(line[\cf7 0\cf4 ], line[\cf7 1\cf4 ], thickness, colour, pixels)\cb1 \
\
\cb3         \cf6 # If we haven't reached max_depth, draw some new triangles\cf4 \cb1 \
\cb3         \cf2 if\cf4  (iteration < max_depth \cf2 and\cf4  (iteration < \cf7 1\cf4  \cf2 or\cf4  line_number < \cf7 3\cf4 )):\cb1 \
\cb3             gradient = (line[\cf7 1\cf4 ][\cf7 0\cf4 ] - line[\cf7 0\cf4 ][\cf7 0\cf4 ]) / (line[\cf7 1\cf4 ][\cf7 1\cf4 ] - line[\cf7 0\cf4 ][\cf7 1\cf4 ])\cb1 \
\
\cb3             new_side_length = side_length*shrink_side_by\cb1 \
\
\cb3             \cf6 # Center of the line of the traingle we are drawing\cf4 \cb1 \
\cb3             center_of_line = [(line[\cf7 0\cf4 ][\cf7 0\cf4 ] + line[\cf7 1\cf4 ][\cf7 0\cf4 ]) / \cf7 2\cf4 , \\\cb1 \
\cb3                               (line[\cf7 0\cf4 ][\cf7 1\cf4 ] + line[\cf7 1\cf4 ][\cf7 1\cf4 ]) / \cf7 2\cf4 ]\cb1 \
\
\cb3             new_center = []\cb1 \
\cb3             new_rotation = degrees_rotate\cb1 \
\
\cb3             \cf6 # Amount we need to rotate the traingle by\cf4 \cb1 \
\cb3             \cf2 if\cf4  (line_number == \cf7 1\cf4 ):\cb1 \
\cb3                 new_rotation += \cf7 60\cf4 \cb1 \
\cb3             \cf2 elif\cf4  (line_number == \cf7 2\cf4 ):\cb1 \
\cb3                 new_rotation -= \cf7 60\cf4 \cb1 \
\cb3             \cf2 else\cf4 :\cb1 \
\cb3                 new_rotation += \cf7 180\cf4 \cb1 \
\cb3             \cb1 \
\cb3             \cf6 # In an ideal world this would be gradient == 0,\cf4 \cb1 \
\cb3             \cf6 # but due to floating point division we cannot\cf4 \cb1 \
\cb3             \cf6 # ensure that this will always be the case\cf4 \cb1 \
\cb3             \cf2 if\cf4  (gradient < \cf7 0.0001\cf4  \cf2 and\cf4  gradient > -\cf7 0.0001\cf4 ):\cb1 \
\cb3                 \cf2 if\cf4  (center_of_line[\cf7 0\cf4 ] - center[\cf7 0\cf4 ] > \cf7 0\cf4 ):\cb1 \
\cb3                     new_center = [center_of_line[\cf7 0\cf4 ] + triangle_height * \\\cb1 \
\cb3                                  (shrink_side_by/\cf7 2\cf4 ), center_of_line[\cf7 1\cf4 ]]\cb1 \
\cb3                 \cf2 else\cf4 :\cb1 \
\cb3                     new_center = [center_of_line[\cf7 0\cf4 ] - triangle_height * \\\cb1 \
\cb3                                   (shrink_side_by/\cf7 2\cf4 ), center_of_line[\cf7 1\cf4 ]]\cb1 \
\cb3                     \cb1 \
\cb3             \cf2 else\cf4 :\cb1 \
\cb3                 \cb1 \
\cb3                 \cf6 # Calculate the normal to the gradient of the line\cf4 \cb1 \
\cb3                 difference_from_center = -\cf7 1\cf4 /gradient\cb1 \
\
\cb3                 \cf6 # Calculate the distance from the center of the line\cf4 \cb1 \
\cb3                 \cf6 # to the center of our new traingle\cf4 \cb1 \
\cb3                 distance_from_center = triangle_height * (shrink_side_by/\cf7 2\cf4 )\cb1 \
\
\cb3                 \cf6 # Calculate the length in the x direction, \cf4 \cb1 \
\cb3                 \cf6 # from the center of our line to the center of our new triangle\cf4 \cb1 \
\cb3                 x_length = math.sqrt((distance_from_center**\cf7 2\cf4 )/ \\\cb1 \
\cb3                                      (\cf7 1\cf4  + difference_from_center**\cf7 2\cf4 ))\cb1 \
\
\cb3                 \cf6 # Figure out which way around the x direction needs to go\cf4 \cb1 \
\cb3                 \cf2 if\cf4  (center_of_line[\cf7 1\cf4 ] < center[\cf7 1\cf4 ] \cf2 and\cf4  x_length > \cf7 0\cf4 ):\cb1 \
\cb3                     x_length *= -\cf7 1\cf4 \cb1 \
\
\cb3                 \cf6 # Now calculate the length in the y direction\cf4 \cb1 \
\cb3                 y_length = x_length * difference_from_center\cb1 \
\
\cb3                 \cf6 # Offset the center of the line with our new x and y values\cf4 \cb1 \
\cb3                 new_center = [center_of_line[\cf7 0\cf4 ] + y_length, \\\cb1 \
\cb3                               center_of_line[\cf7 1\cf4 ] + x_length]\cb1 \
\
\cb3             draw_triangle(new_center, new_side_length, new_rotation, \\\cb1 \
\cb3                           thickness, colour, pixels, shrink_side_by, \\\cb1 \
\cb3                           iteration+\cf7 1\cf4 , max_depth)\
\
\
\'97\'97\'97\'97\cf4 \cb3 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
\
\
}